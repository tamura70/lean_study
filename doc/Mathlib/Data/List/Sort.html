<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Data.List.Sort</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Data.List.Sort";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Data</span>.<span class="name">List</span>.<span class="name">Sort</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Batteries/Data/List/Pairwise.html">Batteries.Data.List.Pairwise</a></li><li><a href="../../.././Batteries/Data/List/Perm.html">Batteries.Data.List.Perm</a></li><li><a href="../../.././Mathlib/Data/List/Nodup.html">Mathlib.Data.List.Nodup</a></li><li><a href="../../.././Mathlib/Data/List/OfFn.html">Mathlib.Data.List.OfFn</a></li><li><a href="../../.././Mathlib/Order/Fin/Basic.html">Mathlib.Order.Fin.Basic</a></li><li><a href="../../.././Init/Data/List/Sort/Basic.html">Init.Data.List.Sort.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Data.List.Sort" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert"><span class="name">List</span>.<span class="name">orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_nil"><span class="name">List</span>.<span class="name">orderedInsert_nil</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_cons"><span class="name">List</span>.<span class="name">orderedInsert_cons</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_cons_of_le"><span class="name">List</span>.<span class="name">orderedInsert_cons_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_of_le"><span class="name">List</span>.<span class="name">orderedInsert_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_of_not_le"><span class="name">List</span>.<span class="name">orderedInsert_of_not_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.insertionSort"><span class="name">List</span>.<span class="name">insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.insertionSort_nil"><span class="name">List</span>.<span class="name">insertionSort_nil</span></a></div><div class="nav_link"><a class="break_within" href="#List.insertionSort_cons"><span class="name">List</span>.<span class="name">insertionSort_cons</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_length"><span class="name">List</span>.<span class="name">orderedInsert_length</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_eq_take_drop"><span class="name">List</span>.<span class="name">orderedInsert_eq_take_drop</span></a></div><div class="nav_link"><a class="break_within" href="#List.insertionSort_cons_eq_take_drop"><span class="name">List</span>.<span class="name">insertionSort_cons_eq_take_drop</span></a></div><div class="nav_link"><a class="break_within" href="#List.mem_orderedInsert"><span class="name">List</span>.<span class="name">mem_orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.map_orderedInsert"><span class="name">List</span>.<span class="name">map_orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.perm_orderedInsert"><span class="name">List</span>.<span class="name">perm_orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_count"><span class="name">List</span>.<span class="name">orderedInsert_count</span></a></div><div class="nav_link"><a class="break_within" href="#List.perm_insertionSort"><span class="name">List</span>.<span class="name">perm_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.mem_insertionSort"><span class="name">List</span>.<span class="name">mem_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.length_insertionSort"><span class="name">List</span>.<span class="name">length_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.insertionSort_cons_of_forall_rel"><span class="name">List</span>.<span class="name">insertionSort_cons_of_forall_rel</span></a></div><div class="nav_link"><a class="break_within" href="#List.map_insertionSort"><span class="name">List</span>.<span class="name">map_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.insertionSort_eq"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">insertionSort_eq</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.insertionSort_eq"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">insertionSort_eq</span></a></div><div class="nav_link"><a class="break_within" href="#List.erase_orderedInsert"><span class="name">List</span>.<span class="name">erase_orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.erase_orderedInsert_of_notMem"><span class="name">List</span>.<span class="name">erase_orderedInsert_of_notMem</span></a></div><div class="nav_link"><a class="break_within" href="#List.orderedInsert_erase"><span class="name">List</span>.<span class="name">orderedInsert_erase</span></a></div><div class="nav_link"><a class="break_within" href="#List.sublist_orderedInsert"><span class="name">List</span>.<span class="name">sublist_orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.cons_sublist_orderedInsert"><span class="name">List</span>.<span class="name">cons_sublist_orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sublist.orderedInsert_sublist"><span class="name">List</span>.<span class="name">Sublist</span>.<span class="name">orderedInsert_sublist</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.orderedInsert"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.orderedInsert"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">orderedInsert</span></a></div><div class="nav_link"><a class="break_within" href="#List.pairwise_insertionSort"><span class="name">List</span>.<span class="name">pairwise_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_insertionSort"><span class="name">List</span>.<span class="name">sorted_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.sublist_insertionSort"><span class="name">List</span>.<span class="name">sublist_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.pair_sublist_insertionSort"><span class="name">List</span>.<span class="name">pair_sublist_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.sublist_insertionSort'"><span class="name">List</span>.<span class="name">sublist_insertionSort'</span></a></div><div class="nav_link"><a class="break_within" href="#List.pair_sublist_insertionSort'"><span class="name">List</span>.<span class="name">pair_sublist_insertionSort'</span></a></div><div class="nav_link"><a class="break_within" href="#List.Perm.eq_of_pairwise'"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_of_pairwise'</span></a></div><div class="nav_link"><a class="break_within" href="#List.eq_of_perm_of_sorted"><span class="name">List</span>.<span class="name">eq_of_perm_of_sorted</span></a></div><div class="nav_link"><a class="break_within" href="#List.sublist_of_subperm_of_pairwise"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.sublist_of_subperm_of_sorted"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_sorted</span></a></div><div class="nav_link"><a class="break_within" href="#List.Subset.antisymm_of_pairwise"><span class="name">List</span>.<span class="name">Subset</span>.<span class="name">antisymm_of_pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.eq_of_mem_iff"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">eq_of_mem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.eq_of_mem_iff"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">eq_of_mem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.merge"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">merge</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.merge"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">merge</span></a></div><div class="nav_link"><a class="break_within" href="#List.pairwise_mergeSort'"><span class="name">List</span>.<span class="name">pairwise_mergeSort'</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_mergeSort'"><span class="name">List</span>.<span class="name">sorted_mergeSort'</span></a></div><div class="nav_link"><a class="break_within" href="#List.mergeSort_eq_self"><span class="name">List</span>.<span class="name">mergeSort_eq_self</span></a></div><div class="nav_link"><a class="break_within" href="#List.mergeSort_eq_insertionSort"><span class="name">List</span>.<span class="name">mergeSort_eq_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE"><span class="name">List</span>.<span class="name">SortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE"><span class="name">List</span>.<span class="name">SortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT"><span class="name">List</span>.<span class="name">SortedLT</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT"><span class="name">List</span>.<span class="name">SortedGT</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_iff_monotone_get"><span class="name">List</span>.<span class="name">sortedLE_iff_monotone_get</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_iff_antitone_get"><span class="name">List</span>.<span class="name">sortedGE_iff_antitone_get</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_iff_strictMono_get"><span class="name">List</span>.<span class="name">sortedLT_iff_strictMono_get</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_iff_strictAnti_get"><span class="name">List</span>.<span class="name">sortedGT_iff_strictAnti_get</span></a></div><div class="nav_link"><a class="break_within" href="#Monotone.sortedLE"><span class="name">Monotone</span>.<span class="name">sortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.monotone_get"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">monotone_get</span></a></div><div class="nav_link"><a class="break_within" href="#Antitone.sortedGE"><span class="name">Antitone</span>.<span class="name">sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.antitone_get"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">antitone_get</span></a></div><div class="nav_link"><a class="break_within" href="#StrictMono.sortedLT"><span class="name">StrictMono</span>.<span class="name">sortedLT</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.strictMono_get"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">strictMono_get</span></a></div><div class="nav_link"><a class="break_within" href="#StrictAnti.sortedGT"><span class="name">StrictAnti</span>.<span class="name">sortedGT</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.strictAnti_get"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">strictAnti_get</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_iff_pairwise"><span class="name">List</span>.<span class="name">sortedLE_iff_pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_iff_pairwise"><span class="name">List</span>.<span class="name">sortedGE_iff_pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_iff_pairwise"><span class="name">List</span>.<span class="name">sortedLT_iff_pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_iff_pairwise"><span class="name">List</span>.<span class="name">sortedGT_iff_pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.sortedLE"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.pairwise"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.sortedGE"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.pairwise"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.sortedLT"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedLT</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.pairwise"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.pairwise"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">pairwise</span></a></div><div class="nav_link"><a class="break_within" href="#List.Pairwise.sortedGT"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedGT</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_iff_isChain"><span class="name">List</span>.<span class="name">sortedLE_iff_isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_iff_isChain"><span class="name">List</span>.<span class="name">sortedGE_iff_isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_iff_isChain"><span class="name">List</span>.<span class="name">sortedLT_iff_isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_iff_isChain"><span class="name">List</span>.<span class="name">sortedGT_iff_isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.IsChain.sortedLE"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.isChain"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.IsChain.sortedGE"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.isChain"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.isChain"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.IsChain.sortedLT"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedLT</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.isChain"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">isChain</span></a></div><div class="nav_link"><a class="break_within" href="#List.IsChain.sortedGT"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedGT</span></a></div><div class="nav_link"><a class="break_within" href="#List.decidableSortedLE"><span class="name">List</span>.<span class="name">decidableSortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.decidableSortedGE"><span class="name">List</span>.<span class="name">decidableSortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.decidableSortedLT"><span class="name">List</span>.<span class="name">decidableSortedLT</span></a></div><div class="nav_link"><a class="break_within" href="#List.decidableSortedGT"><span class="name">List</span>.<span class="name">decidableSortedGT</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_iff_getElem_le_getElem_of_le"><span class="name">List</span>.<span class="name">sortedLE_iff_getElem_le_getElem_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_iff_getElem_ge_getElem_of_le"><span class="name">List</span>.<span class="name">sortedGE_iff_getElem_ge_getElem_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_iff_getElem_lt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedLT_iff_getElem_lt_getElem_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_iff_getElem_gt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedGT_iff_getElem_gt_getElem_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_of_getElem_le_getElem_of_le"><span class="name">List</span>.<span class="name">sortedLE_of_getElem_le_getElem_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.getElem_le_getElem_of_le"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">getElem_le_getElem_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.getElem_ge_getElem_of_le"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">getElem_ge_getElem_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_of_getElem_ge_getElem_of_le"><span class="name">List</span>.<span class="name">sortedGE_of_getElem_ge_getElem_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_of_getElem_lt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedLT_of_getElem_lt_getElem_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.getElem_lt_getElem_of_lt"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">getElem_lt_getElem_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_of_getElem_gt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedGT_of_getElem_gt_getElem_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.getElem_gt_getElem_of_lt"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">getElem_gt_getElem_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.sortedLE"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">sortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.sortedGE"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.le_of_lt"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">le_of_lt</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.ge_of_gt"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">ge_of_gt</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.nodup"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">nodup</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.nodup"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">nodup</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_replicate"><span class="name">List</span>.<span class="name">sortedLE_replicate</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_le_replicate"><span class="name">List</span>.<span class="name">sorted_le_replicate</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_finRange"><span class="name">List</span>.<span class="name">sortedLT_finRange</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_range"><span class="name">List</span>.<span class="name">sortedLT_range</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_lt_range"><span class="name">List</span>.<span class="name">sorted_lt_range</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_le_range"><span class="name">List</span>.<span class="name">sorted_le_range</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_range'"><span class="name">List</span>.<span class="name">sortedLT_range'</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_lt_range'"><span class="name">List</span>.<span class="name">sorted_lt_range'</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_le_range'"><span class="name">List</span>.<span class="name">sorted_le_range'</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_range'"><span class="name">List</span>.<span class="name">sortedLE_range'</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_ofFn_iff"><span class="name">List</span>.<span class="name">sortedLE_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_ofFn_iff"><span class="name">List</span>.<span class="name">sortedGE_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_ofFn_iff"><span class="name">List</span>.<span class="name">sortedLT_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_ofFn_iff"><span class="name">List</span>.<span class="name">sortedGT_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_le_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_le_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_lt_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_lt_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_ge_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_ge_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.sorted_gt_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_gt_ofFn_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Monotone.sortedLE_ofFn"><span class="name">Monotone</span>.<span class="name">sortedLE_ofFn</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.monotone"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">monotone</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.antitone"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">antitone</span></a></div><div class="nav_link"><a class="break_within" href="#Antitone.sortedGE_ofFn"><span class="name">Antitone</span>.<span class="name">sortedGE_ofFn</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.strictMono"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">strictMono</span></a></div><div class="nav_link"><a class="break_within" href="#StrictMono.sortedLT_ofFn"><span class="name">StrictMono</span>.<span class="name">sortedLT_ofFn</span></a></div><div class="nav_link"><a class="break_within" href="#StrictAnti.sortedGT_ofFn"><span class="name">StrictAnti</span>.<span class="name">sortedGT_ofFn</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.strictAnti"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">strictAnti</span></a></div><div class="nav_link"><a class="break_within" href="#Antitone.ofFn_sorted"><span class="name">Antitone</span>.<span class="name">ofFn_sorted</span></a></div><div class="nav_link"><a class="break_within" href="#Monotone.ofFn_sorted"><span class="name">Monotone</span>.<span class="name">ofFn_sorted</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_reverse"><span class="name">List</span>.<span class="name">sortedLE_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_reverse"><span class="name">List</span>.<span class="name">sortedGE_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_reverse"><span class="name">List</span>.<span class="name">sortedLT_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_reverse"><span class="name">List</span>.<span class="name">sortedGT_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.reverse"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.of_reverse"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">of_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.of_reverse"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">of_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.reverse"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.of_reverse"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">of_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.reverse"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.reverse"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.of_reverse"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">of_reverse</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_map_ofDual"><span class="name">List</span>.<span class="name">sortedLE_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_map_ofDual"><span class="name">List</span>.<span class="name">sortedGE_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_map_ofDual"><span class="name">List</span>.<span class="name">sortedLT_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_map_ofDual"><span class="name">List</span>.<span class="name">sortedGT_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">of_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.map_ofDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.map_ofDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">of_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">of_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.map_ofDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">of_map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.map_ofDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">map_ofDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_map_toDual"><span class="name">List</span>.<span class="name">sortedLE_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_map_toDual"><span class="name">List</span>.<span class="name">sortedGE_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_map_toDual"><span class="name">List</span>.<span class="name">sortedLT_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_map_toDual"><span class="name">List</span>.<span class="name">sortedGT_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.map_toDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.of_map_toDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">of_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.of_map_toDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">of_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.map_toDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.map_toDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.of_map_toDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">of_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.map_toDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.of_map_toDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">of_map_toDual</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLE.sortedLT_of_nodup"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">sortedLT_of_nodup</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGE.sortedGT_of_nodup"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">sortedGT_of_nodup</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.lt_of_le"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">lt_of_le</span></a></div><div class="nav_link"><a class="break_within" href="#List.Sorted.gt_of_ge"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">gt_of_ge</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLT_iff_nodup_and_sortedLE"><span class="name">List</span>.<span class="name">sortedLT_iff_nodup_and_sortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGT_iff_nodup_and_sortedGE"><span class="name">List</span>.<span class="name">sortedGT_iff_nodup_and_sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.Perm.eq_of_sortedLE"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_of_sortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.Perm.eq_of_sortedGE"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_of_sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.Subset.antisymm_of_sortedLT"><span class="name">List</span>.<span class="name">Subset</span>.<span class="name">antisymm_of_sortedLT</span></a></div><div class="nav_link"><a class="break_within" href="#List.Subset.antisymm_of_sortedGT"><span class="name">List</span>.<span class="name">Subset</span>.<span class="name">antisymm_of_sortedGT</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.eq_of_mem_iff"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">eq_of_mem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.eq_of_mem_iff"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">eq_of_mem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.Perm.eq_reverse_of_sortedLE_of_sortedGE"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_reverse_of_sortedLE_of_sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.eq_reverse_of_mem_iff_of_sortedGT"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">eq_reverse_of_mem_iff_of_sortedGT</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.eq_reverse_of_mem_iff_of_sortedLT"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">eq_reverse_of_mem_iff_of_sortedLT</span></a></div><div class="nav_link"><a class="break_within" href="#List.sublist_of_subperm_of_sortedLE"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_sortedLE</span></a></div><div class="nav_link"><a class="break_within" href="#List.sublist_of_subperm_of_sortedGE"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_sortedGE</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_mergeSort"><span class="name">List</span>.<span class="name">sortedLE_mergeSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_mergeSort"><span class="name">List</span>.<span class="name">sortedGE_mergeSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedLE_insertionSort"><span class="name">List</span>.<span class="name">sortedLE_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.sortedGE_insertionSort"><span class="name">List</span>.<span class="name">sortedGE_insertionSort</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.getElem_le_getElem_iff"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">getElem_le_getElem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.getElem_le_getElem_iff"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">getElem_le_getElem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedLT.getElem_lt_getElem_iff"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">getElem_lt_getElem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#List.SortedGT.getElem_lt_getElem_iff"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">getElem_lt_getElem_iff</span></a></div><div class="nav_link"><a class="break_within" href="#RelEmbedding.pairwise_listMap"><span class="name">RelEmbedding</span>.<span class="name">pairwise_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#RelEmbedding.sorted_listMap"><span class="name">RelEmbedding</span>.<span class="name">sorted_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#RelEmbedding.pairwise_swap_listMap"><span class="name">RelEmbedding</span>.<span class="name">pairwise_swap_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#RelEmbedding.sorted_swap_listMap"><span class="name">RelEmbedding</span>.<span class="name">sorted_swap_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#RelIso.pairwise_listMap"><span class="name">RelIso</span>.<span class="name">pairwise_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#RelIso.pairwise_swap_listMap"><span class="name">RelIso</span>.<span class="name">pairwise_swap_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sortedLE_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedLE_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sortedLT_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedLT_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sortedGE_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedGE_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sortedGT_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedGT_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sorted_le_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_le_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sorted_lt_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_lt_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sorted_ge_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_ge_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderEmbedding.sorted_gt_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_gt_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderIso.sortedLT_listMap"><span class="name">OrderIso</span>.<span class="name">sortedLT_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#OrderIso.sortedGT_listMap"><span class="name">OrderIso</span>.<span class="name">sortedGT_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictMono.sortedLE_listMap"><span class="name">StrictMono</span>.<span class="name">sortedLE_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictMono.sortedGE_listMap"><span class="name">StrictMono</span>.<span class="name">sortedGE_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictMono.sortedLT_listMap"><span class="name">StrictMono</span>.<span class="name">sortedLT_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictMono.sortedGT_listMap"><span class="name">StrictMono</span>.<span class="name">sortedGT_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictAnti.sortedLE_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedLE_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictAnti.sortedGE_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedGE_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictAnti.sortedLT_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedLT_listMap</span></a></div><div class="nav_link"><a class="break_within" href="#StrictAnti.sortedGT_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedGT_listMap</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Sorting-algorithms-on-lists">Sorting algorithms on lists <a class="hover-link" href="#Sorting-algorithms-on-lists">#</a></h1><p>In this file we define the sorting algorithm <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">List.insertionSort</a> r</code> and prove
that we have <code>(l.<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> r l).Pairwise r</code> under suitable conditions on <code>r</code>.</p><p>We then define <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">List.SortedLE</a></code>, <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">List.SortedGE</a></code>, <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">List.SortedLT</a></code> and <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">List.SortedGT</a></code>,
predicates which are equivalent to <code><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a></code> when the relation derives from a
preorder (but which are defined in terms of the monotonicity predicates).</p></div><div class="mod_doc"><h3 class="markdown-heading" id="Insertion-sort">Insertion sort <a class="hover-link" href="#Insertion-sort">#</a></h3></div><div class="decl" id="List.orderedInsert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L43-L47">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert"><span class="name">List</span>.<span class="name">orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></div></div><p><code><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> a l</code> inserts <code>a</code> into <code>l</code> at such that
<code><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> a l</code> is sorted if <code>l</code> is.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">List.orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#List.cons">]</a></li><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">List.orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> (<span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">List.orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span></span></li></ul></details><details id="instances-for-list-List.orderedInsert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.orderedInsert_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L49-L49">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_nil"><span class="name">List</span>.<span class="name">orderedInsert_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#List.cons">]</a></div></div></div></div><div class="decl" id="List.orderedInsert_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L51-L53">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_cons"><span class="name">List</span>.<span class="name">orderedInsert_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> (<span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.orderedInsert_cons_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L55-L57">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_cons_of_le"><span class="name">List</span>.<span class="name">orderedInsert_cons_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> (<span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="List.orderedInsert_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L59-L59">source</a></div><div class="attributes">@[deprecated List.orderedInsert_cons_of_le (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_of_le"><span class="name">List</span>.<span class="name">orderedInsert_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> (<span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_cons_of_le">List.orderedInsert_cons_of_le</a></code>.</p></div></div><div class="decl" id="List.orderedInsert_of_not_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L61-L62">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_of_not_le"><span class="name">List</span>.<span class="name">orderedInsert_of_not_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> (<span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.insertionSort"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L64-L65">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort"><span class="name">List</span>.<span class="name">insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></div></div><p><code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> l</code> returns <code>l</code> sorted using the insertion sort algorithm.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">List.insertionSort</a> <span class="fn">r</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">List.orderedInsert</a> <span class="fn">r</span>)</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span></li></ul></details><details id="instances-for-list-List.insertionSort" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.insertionSort_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L67-L68">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort_nil"><span class="name">List</span>.<span class="name">insertionSort_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#List.nil">[</a><a href="../../.././Init/Prelude.html#List.nil">]</a></div></div></div></div><div class="decl" id="List.insertionSort_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L70-L71">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort_cons"><span class="name">List</span>.<span class="name">insertionSort_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="List.orderedInsert_length"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L78-L80">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_length"><span class="name">List</span>.<span class="name">orderedInsert_length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">L</span>)</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">L</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></div></div></div></div><div class="decl" id="List.orderedInsert_eq_take_drop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L82-L85">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_eq_take_drop"><span class="name">List</span>.<span class="name">orderedInsert_eq_take_drop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.takeWhile">takeWhile</a> <span class="fn">(fun (<span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.dropWhile">dropWhile</a> <span class="fn">(fun (<span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> <span class="fn">l</span></span></div></div><p>An alternative definition of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a></code> using <code>takeWhile</code> and <code>dropWhile</code>.</p></div></div><div class="decl" id="List.insertionSort_cons_eq_take_drop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L87-L91">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort_cons_eq_take_drop"><span class="name">List</span>.<span class="name">insertionSort_cons_eq_take_drop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.takeWhile">takeWhile</a> <span class="fn">(fun (<span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a>     <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.dropWhile">dropWhile</a> <span class="fn">(fun (<span class="fn">b</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span>)</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="List.mem_orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L93-L96">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.mem_orderedInsert"><span class="name">List</span>.<span class="name">mem_orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">l</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="List.map_orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L98-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.map_orderedInsert"><span class="name">List</span>.<span class="name">map_orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">s</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → (<span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">x</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">s</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → (<span class="fn"><span class="fn">r</span> <span class="fn">x</span> <span class="fn">a</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">s</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">s</span> <span class="fn">(<span class="fn">f</span> <span class="fn">x</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="List.perm_orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L105-L110">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.perm_orderedInsert"><span class="name">List</span>.<span class="name">perm_orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span>)</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span></div></div></div></div><div class="decl" id="List.orderedInsert_count"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L112-L115">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_count"><span class="name">List</span>.<span class="name">orderedInsert_count</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">L</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.count">count</a> <span class="fn">a</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">b</span> <span class="fn">L</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.count">count</a> <span class="fn">a</span> <span class="fn">L</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <a href="../../.././Init/Prelude.html#ite">if</a> <span class="fn">b</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#ite">then</a> <span class="fn">1</span> <a href="../../.././Init/Prelude.html#ite">else</a> <span class="fn">0</span></div></div></div></div><div class="decl" id="List.perm_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L117-L118">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.perm_insertionSort"><span class="name">List</span>.<span class="name">perm_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.mem_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L120-L122">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.mem_insertionSort"><span class="name">List</span>.<span class="name">mem_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></div></div></div></div><div class="decl" id="List.length_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L124-L126">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.length_insertionSort"><span class="name">List</span>.<span class="name">length_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span></div></div></div></div><div class="decl" id="List.insertionSort_cons_of_forall_rel"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L128-L137">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort_cons_of_forall_rel"><span class="name">List</span>.<span class="name">insertionSort_cons_of_forall_rel</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> (<span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.map_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L139-L148">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.map_insertionSort"><span class="name">List</span>.<span class="name">map_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">s</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">s</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → <span class="fn">∀ (<span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span> → (<span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">s</span> <span class="fn">(<span class="fn">f</span> <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">f</span> <span class="fn">b</span>)</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">f</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">s</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">f</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="List.Pairwise.insertionSort_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L152-L155">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.insertionSort_eq"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">insertionSort_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></div></div><p>If <code>l</code> is already <code><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a></code> with respect to <code>r</code>, then <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a></code> does not change
it.</p></div></div><div class="decl" id="List.Sorted.insertionSort_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L157-L158">source</a></div><div class="attributes">@[deprecated List.Pairwise.insertionSort_eq (since := &quot;2025-10-11&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.insertionSort_eq"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">insertionSort_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.insertionSort_eq">List.Pairwise.insertionSort_eq</a></code>.</p><hr></hr><p>If <code>l</code> is already <code><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a></code> with respect to <code>r</code>, then <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a></code> does not change
it.</p></div></div><div class="decl" id="List.erase_orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L160-L163">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.erase_orderedInsert"><span class="name">List</span>.<span class="name">erase_orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Refl">Std.Refl</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">xs</span>)</span>.<a href="../../.././Init/Data/List/Basic.html#List.erase">erase</a></span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">xs</span></div></div><p>For a reflexive relation, insert then erasing is the identity.</p></div></div><div class="decl" id="List.erase_orderedInsert_of_notMem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L165-L169">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.erase_orderedInsert_of_notMem"><span class="name">List</span>.<span class="name">erase_orderedInsert_of_notMem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">x</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">xs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">xs</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">xs</span>)</span>.<a href="../../.././Init/Data/List/Basic.html#List.erase">erase</a></span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">xs</span></div></div><p>Inserting then erasing an element that is absent is the identity.</p></div></div><div class="decl" id="List.orderedInsert_erase"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L171-L175">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert_erase"><span class="name">List</span>.<span class="name">orderedInsert_erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hx</span> : <span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">xs</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hxs</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">xs</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">(<span class="fn"><span class="fn">xs</span>.<a href="../../.././Init/Data/List/Basic.html#List.erase">erase</a></span> <span class="fn">x</span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">xs</span></div></div><p>For an antisymmetric relation, erasing then inserting is the identity.</p></div></div><div class="decl" id="List.sublist_orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L177-L178">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sublist_orderedInsert"><span class="name">List</span>.<span class="name">sublist_orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">xs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">xs</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">xs</span>)</span></span></div></div></div></div><div class="decl" id="List.cons_sublist_orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L180-L182">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.cons_sublist_orderedInsert"><span class="name">List</span>.<span class="name">cons_sublist_orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">c</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">ha</span> : <span class="fn">∀ (<span class="fn">a'</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a'</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">c</span> → <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">a'</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn">a</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">c</span>).<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span>)</span></span></div></div></div></div><div class="decl" id="List.Sublist.orderedInsert_sublist"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L184-L204">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sublist.orderedInsert_sublist"><span class="name">List</span>.<span class="name">Sublist</span>.<span class="name">orderedInsert_sublist</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">as </span><span class="fn">bs</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><span class="fn"><span class="fn">as</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">bs</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hb</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">bs</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">as</span>)</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">orderedInsert</a> <span class="fn">r</span> <span class="fn">x</span> <span class="fn">bs</span>)</span></span></div></div></div></div><div class="decl" id="List.Pairwise.orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L210-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.orderedInsert"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l</span></span> → <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">List.orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span>)</span></span></span></div></div></div></div><div class="decl" id="List.Sorted.orderedInsert"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L223-L224">source</a></div><div class="attributes">@[deprecated List.Pairwise.orderedInsert (since := &quot;2025-10-11&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.orderedInsert"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">orderedInsert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l</span></span> → <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.orderedInsert">List.orderedInsert</a> <span class="fn">r</span> <span class="fn">a</span> <span class="fn">l</span>)</span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.orderedInsert">List.Pairwise.orderedInsert</a></code>.</p></div></div><div class="decl" id="List.pairwise_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L228-L231">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.pairwise_insertionSort"><span class="name">List</span>.<span class="name">pairwise_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div><p>The list <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">List.insertionSort</a> r l</code> is <code><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a></code> with respect to <code>r</code>.</p></div></div><div class="decl" id="List.sorted_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L233-L234">source</a></div><div class="attributes">@[deprecated List.pairwise_insertionSort (since := &quot;2025-10-11&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_insertionSort"><span class="name">List</span>.<span class="name">sorted_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.pairwise_insertionSort">List.pairwise_insertionSort</a></code>.</p><hr></hr><p>The list <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">List.insertionSort</a> r l</code> is <code><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a></code> with respect to <code>r</code>.</p></div></div><div class="decl" id="List.sublist_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L239-L251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sublist_insertionSort"><span class="name">List</span>.<span class="name">sublist_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">c</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hr</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div><p>If <code>c</code> is a sorted sublist of <code>l</code>, then <code>c</code> is still a sublist of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> r l</code>.</p></div></div><div class="decl" id="List.pair_sublist_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L253-L260">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.pair_sublist_insertionSort"><span class="name">List</span>.<span class="name">pair_sublist_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#List.cons">,</a> <span class="fn">b</span><a href="../../.././Init/Prelude.html#List.cons">]</a>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#List.cons">,</a> <span class="fn">b</span><a href="../../.././Init/Prelude.html#List.cons">]</a>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div><p>Another statement of stability of insertion sort.
If a pair <code>[a, b]</code> is a sublist of <code>l</code> and <code>r a b</code>,
then <code>[a, b]</code> is still a sublist of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> r l</code>.</p></div></div><div class="decl" id="List.sublist_insertionSort'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L265-L282">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sublist_insertionSort'"><span class="name">List</span>.<span class="name">sublist_insertionSort'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">c</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hc</span> : <span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Batteries/Data/List/Basic.html#List.Subperm">Subperm</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div><p>A version of <code>insertionSort_stable</code> which only assumes <code>c &lt;+~ l</code> (instead of <code>c &lt;+ l</code>), but
additionally requires <code><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> r</code>, <code><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> r</code> and <code><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> α r</code>.</p></div></div><div class="decl" id="List.pair_sublist_insertionSort'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L284-L291">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.pair_sublist_insertionSort'"><span class="name">List</span>.<span class="name">pair_sublist_insertionSort'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hab</span> : <span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#List.cons">,</a> <span class="fn">b</span><a href="../../.././Init/Prelude.html#List.cons">]</a>.<a href="../../.././Batteries/Data/List/Basic.html#List.Subperm">Subperm</a></span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List.cons">[</a><span class="fn">a</span><a href="../../.././Init/Prelude.html#List.cons">,</a> <span class="fn">b</span><a href="../../.././Init/Prelude.html#List.cons">]</a>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span>)</span></span></div></div><p>Another statement of stability of insertion sort.
If a pair <code>[a, b]</code> is a sublist of a permutation of <code>l</code> and <code>a ≼ b</code>,
then <code>[a, b]</code> is still a sublist of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> r l</code>.</p></div></div><div class="mod_doc"><h3 class="markdown-heading" id="Merge-sort">Merge sort <a class="hover-link" href="#Merge-sort">#</a></h3><p>We provide some wrapper functions around the theorems for <code>mergeSort</code> provided in Lean,
which rather than using explicit hypotheses for transitivity and totality,
use Mathlib order typeclasses instead.</p></div><div class="decl" id="List.Perm.eq_of_pairwise'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L316-L319">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Perm.eq_of_pairwise'"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_of_pairwise'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₁</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₂</span></span> → <span class="fn">∀ (<span class="fn">hl</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l₂</span></span>), <span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></span></span></span></div></div><p>Variant of <code>Perm.eq_of_pairwise</code> using relation typeclasses.</p></div></div><div class="decl" id="List.eq_of_perm_of_sorted"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L321-L322">source</a></div><div class="attributes">@[deprecated List.Perm.eq_of_pairwise (since := &quot;2025-10-11&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.eq_of_perm_of_sorted"><span class="name">List</span>.<span class="name">eq_of_perm_of_sorted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">le</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ (<span class="fn">a </span><span class="fn">b</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span> → <span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span> → <span class="fn"><span class="fn"><span class="fn">le</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">le</span> <span class="fn">b</span> <span class="fn">a</span></span> → <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></span></span></span>)</span> → <span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">le</span> <span class="fn">l₁</span></span> → <span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">le</span> <span class="fn">l₂</span></span> → <span class="fn"><span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l₂</span></span> → <span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></span></span></span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Init/Data/List/Perm.html#List.Perm.eq_of_pairwise">List.Perm.eq_of_pairwise</a></code>.</p></div></div><div class="decl" id="List.sublist_of_subperm_of_pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L324-L327">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sublist_of_subperm_of_pairwise"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Batteries/Data/List/Basic.html#List.Subperm">Subperm</a></span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs₁</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs₂</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l₂</span></span></div></div></div></div><div class="decl" id="List.sublist_of_subperm_of_sorted"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L329-L330">source</a></div><div class="attributes">@[deprecated List.sublist_of_subperm_of_pairwise (since := &quot;2025-10-11&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sublist_of_subperm_of_sorted"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_sorted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Batteries/Data/List/Basic.html#List.Subperm">Subperm</a></span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs₁</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hs₂</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l₂</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sublist_of_subperm_of_pairwise">List.sublist_of_subperm_of_pairwise</a></code>.</p></div></div><div class="decl" id="List.Subset.antisymm_of_pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L332-L335">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Subset.antisymm_of_pairwise"><span class="name">List</span>.<span class="name">Subset</span>.<span class="name">antisymm_of_pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Irrefl">Std.Irrefl</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂</span> : <span class="fn">l₁</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂'</span> : <span class="fn">l₂</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">l₁</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.Pairwise.eq_of_mem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L337-L339">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.eq_of_mem_iff"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">eq_of_mem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Irrefl">Std.Irrefl</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.Sorted.eq_of_mem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L341-L342">source</a></div><div class="attributes">@[deprecated List.Pairwise.eq_of_mem_iff (since := &quot;2025-10-11&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.eq_of_mem_iff"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">eq_of_mem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Irrefl">Std.Irrefl</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.eq_of_mem_iff">List.Pairwise.eq_of_mem_iff</a></code>.</p></div></div><div class="decl" id="List.Pairwise.merge"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L350-L355">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.merge"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">merge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.merge">merge</a></span> <span class="fn">l'</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">r</span> <span class="fn">x1</span> <span class="fn">x2</span>)</span></span></span>)</span></span></div></div></div></div><div class="decl" id="List.Sorted.merge"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L357-L357">source</a></div><div class="attributes">@[deprecated List.Pairwise.merge (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.merge"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">merge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l </span><span class="fn">l'</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h'</span> : <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.merge">merge</a></span> <span class="fn">l'</span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">r</span> <span class="fn">x1</span> <span class="fn">x2</span>)</span></span></span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.merge">List.Pairwise.merge</a></code>.</p></div></div><div class="decl" id="List.pairwise_mergeSort'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L361-L366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.pairwise_mergeSort'"><span class="name">List</span>.<span class="name">pairwise_mergeSort'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.mergeSort">mergeSort</a></span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">r</span> <span class="fn">x1</span> <span class="fn">x2</span>)</span></span></span>)</span></span></div></div><p>Variant of <code>pairwise_mergeSort</code> using relation typeclasses.</p></div></div><div class="decl" id="List.sorted_mergeSort'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L368-L368">source</a></div><div class="attributes">@[deprecated List.pairwise_mergeSort' (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_mergeSort'"><span class="name">List</span>.<span class="name">sorted_mergeSort'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.mergeSort">mergeSort</a></span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">r</span> <span class="fn">x1</span> <span class="fn">x2</span>)</span></span></span>)</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.pairwise_mergeSort'">List.pairwise_mergeSort'</a></code>.</p><hr></hr><p>Variant of <code>pairwise_mergeSort</code> using relation typeclasses.</p></div></div><div class="decl" id="List.mergeSort_eq_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L372-L373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.mergeSort_eq_self"><span class="name">List</span>.<span class="name">mergeSort_eq_self</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">r</span> <span class="fn">l</span></span> → <span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.mergeSort">mergeSort</a></span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">r</span> <span class="fn">x1</span> <span class="fn">x2</span>)</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.mergeSort_eq_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L375-L378">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.mergeSort_eq_insertionSort"><span class="name">List</span>.<span class="name">mergeSort_eq_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">r</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Total">Std.Total</a> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/Unbundled.html#IsTrans">IsTrans</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Core.html#Std.Antisymm">Std.Antisymm</a> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.mergeSort">mergeSort</a></span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn">r</span> <span class="fn">x1</span> <span class="fn">x2</span>)</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">r</span> <span class="fn">l</span></span></div></div></div></div><div class="mod_doc"><h3 class="markdown-heading" id="The-predicates-List-SortedLE-List-SortedGE-List-SortedLT-and-List-SortedGT">The predicates <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">List.SortedLE</a></code>, <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">List.SortedGE</a></code>, <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">List.SortedLT</a></code> and <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">List.SortedGT</a></code> <a class="hover-link" href="#The-predicates-List-SortedLE-List-SortedGE-List-SortedLT-and-List-SortedGT">#</a></h3></div><div class="mod_doc"><p>These predicates are equivalent to <code><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> l.get</code>, but they are also equivalent to
<code>IsChain (· &lt; ·)</code> and <code>Pairwise (· &lt; ·)</code>. API is provided to move between these forms.</p><h2 class="markdown-heading" id="API-has-deliberately-not-been-provided-for-decomposed-lists-to-avoid-unneeded-API-replication-The-provided-API-should-be-used-to-move-to-and-from-IsChain-Pairwise-or-Monotone-as-needed">API has deliberately not been provided for decomposed lists to avoid unneeded API replication.
The provided API should be used to move to and from <code>IsChain</code>,
<code>Pairwise</code> or <code><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a></code> as needed. <a class="hover-link" href="#API-has-deliberately-not-been-provided-for-decomposed-lists-to-avoid-unneeded-API-replication-The-provided-API-should-be-used-to-move-to-and-from-IsChain-Pairwise-or-Monotone-as-needed">#</a></h2></div><div class="decl" id="List.SortedLE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L409-L410">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE"><span class="name">List</span>.<span class="name">SortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>l.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></code> means that the list is monotonic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></li></ul></details><details id="instances-for-list-List.SortedLE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.SortedGE"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L411-L412">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE"><span class="name">List</span>.<span class="name">SortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>l.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></code> means that the list is antitonic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></li></ul></details><details id="instances-for-list-List.SortedGE" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.SortedLT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L413-L414">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT"><span class="name">List</span>.<span class="name">SortedLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>l.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></code> means that the list is strictly monotonic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></li></ul></details><details id="instances-for-list-List.SortedLT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.SortedGT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L415-L416">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT"><span class="name">List</span>.<span class="name">SortedGT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p><code>l.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></code> means that the list is strictly antitonic.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></li></ul></details><details id="instances-for-list-List.SortedGT" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="List.sortedLE_iff_monotone_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L420-L420">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_monotone_get"><span class="name">List</span>.<span class="name">sortedLE_iff_monotone_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></div></div></div></div><div class="decl" id="List.sortedGE_iff_antitone_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L421-L421">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_antitone_get"><span class="name">List</span>.<span class="name">sortedGE_iff_antitone_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></div></div></div></div><div class="decl" id="List.sortedLT_iff_strictMono_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L422-L422">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_strictMono_get"><span class="name">List</span>.<span class="name">sortedLT_iff_strictMono_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></div></div></div></div><div class="decl" id="List.sortedGT_iff_strictAnti_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L423-L423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_strictAnti_get"><span class="name">List</span>.<span class="name">sortedGT_iff_strictAnti_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></div></div></div></div><div class="decl" id="Monotone.sortedLE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L425-L425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#Monotone.sortedLE"><span class="name">Monotone</span>.<span class="name">sortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_monotone_get">List.sortedLE_iff_monotone_get</a></code>.</p></div></div><div class="decl" id="List.SortedLE.monotone_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L425-L425">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.monotone_get"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">monotone_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_monotone_get">List.sortedLE_iff_monotone_get</a></code>.</p></div></div><div class="decl" id="Antitone.sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L426-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#Antitone.sortedGE"><span class="name">Antitone</span>.<span class="name">sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_antitone_get">List.sortedGE_iff_antitone_get</a></code>.</p></div></div><div class="decl" id="List.SortedGE.antitone_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L426-L426">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.antitone_get"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">antitone_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_antitone_get">List.sortedGE_iff_antitone_get</a></code>.</p></div></div><div class="decl" id="StrictMono.sortedLT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L427-L427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictMono.sortedLT"><span class="name">StrictMono</span>.<span class="name">sortedLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_strictMono_get">List.sortedLT_iff_strictMono_get</a></code>.</p></div></div><div class="decl" id="List.SortedLT.strictMono_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L427-L427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.strictMono_get"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">strictMono_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_strictMono_get">List.sortedLT_iff_strictMono_get</a></code>.</p></div></div><div class="decl" id="StrictAnti.sortedGT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L428-L428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictAnti.sortedGT"><span class="name">StrictAnti</span>.<span class="name">sortedGT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_strictAnti_get">List.sortedGT_iff_strictAnti_get</a></code>.</p></div></div><div class="decl" id="List.SortedGT.strictAnti_get"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L428-L428">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.strictAnti_get"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">strictAnti_get</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.get">get</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_strictAnti_get">List.sortedGT_iff_strictAnti_get</a></code>.</p></div></div><div class="decl" id="List.sortedLE_iff_pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L434-L436">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_pairwise"><span class="name">List</span>.<span class="name">sortedLE_iff_pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.sortedGE_iff_pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L437-L439">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_pairwise"><span class="name">List</span>.<span class="name">sortedGE_iff_pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.sortedLT_iff_pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L440-L442">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_pairwise"><span class="name">List</span>.<span class="name">sortedLT_iff_pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.sortedGT_iff_pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L443-L445">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_pairwise"><span class="name">List</span>.<span class="name">sortedGT_iff_pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.Pairwise.sortedLE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L447-L447">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.sortedLE"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_pairwise">List.sortedLE_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.SortedLE.pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L447-L447">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.pairwise"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_pairwise">List.sortedLE_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.Pairwise.sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L448-L448">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.sortedGE"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_pairwise">List.sortedGE_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.SortedGE.pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L448-L448">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.pairwise"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_pairwise">List.sortedGE_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.Pairwise.sortedLT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L449-L449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.sortedLT"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_pairwise">List.sortedLT_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.SortedLT.pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L449-L449">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.pairwise"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_pairwise">List.sortedLT_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.SortedGT.pairwise"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L450-L450">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.pairwise"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">pairwise</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_pairwise">List.sortedGT_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.Pairwise.sortedGT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L450-L450">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Pairwise.sortedGT"><span class="name">List</span>.<span class="name">Pairwise</span>.<span class="name">sortedGT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">Pairwise</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_pairwise">List.sortedGT_iff_pairwise</a></code>.</p></div></div><div class="decl" id="List.sortedLE_iff_isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L456-L457">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_isChain"><span class="name">List</span>.<span class="name">sortedLE_iff_isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.sortedGE_iff_isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L458-L459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_isChain"><span class="name">List</span>.<span class="name">sortedGE_iff_isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.sortedLT_iff_isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L460-L461">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_isChain"><span class="name">List</span>.<span class="name">sortedLT_iff_isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.sortedGT_iff_isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L462-L463">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_isChain"><span class="name">List</span>.<span class="name">sortedGT_iff_isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="List.IsChain.sortedLE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L465-L465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.IsChain.sortedLE"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_isChain">List.sortedLE_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.SortedLE.isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L465-L465">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.isChain"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_isChain">List.sortedLE_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.IsChain.sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L466-L466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.IsChain.sortedGE"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_isChain">List.sortedGE_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.SortedGE.isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L466-L466">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.isChain"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_isChain">List.sortedGE_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.SortedLT.isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L467-L467">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.isChain"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_isChain">List.sortedLT_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.IsChain.sortedLT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L467-L467">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.IsChain.sortedLT"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_isChain">List.sortedLT_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.SortedGT.isChain"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L468-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.isChain"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">isChain</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_isChain">List.sortedGT_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.IsChain.sortedGT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L468-L468">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.IsChain.sortedGT"><span class="name">List</span>.<span class="name">IsChain</span>.<span class="name">sortedGT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">x2</span>)</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_isChain">List.sortedGT_iff_isChain</a></code>.</p></div></div><div class="decl" id="List.decidableSortedLE"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L472-L473">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedLE"><span class="name">List</span>.<span class="name">decidableSortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedLE">decidableSortedLE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/PropLemmas.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">List.IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">x✝</span>)</span> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="List.decidableSortedGE"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L474-L475">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedGE"><span class="name">List</span>.<span class="name">decidableSortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLE">DecidableLE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedGE">decidableSortedGE</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/PropLemmas.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">List.IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">x✝</span>)</span> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="List.decidableSortedLT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L476-L477">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedLT"><span class="name">List</span>.<span class="name">decidableSortedLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedLT">decidableSortedLT</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/PropLemmas.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">List.IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x2</span>)</span> <span class="fn">x✝</span>)</span> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="List.decidableSortedGT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L478-L479">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedGT"><span class="name">List</span>.<span class="name">decidableSortedGT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableLT">DecidableLT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">x✝</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.decidableSortedGT">decidableSortedGT</a></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/PropLemmas.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<a href="../../.././Batteries/Data/List/Basic.html#List.IsChain">List.IsChain</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GT.gt">&gt;</a> <span class="fn">x2</span>)</span> <span class="fn">x✝</span>)</span> <span class="fn">⋯</span></span></li></ul></details></div></div><div class="decl" id="List.sortedLE_iff_getElem_le_getElem_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L487-L489">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_getElem_le_getElem_of_le"><span class="name">List</span>.<span class="name">sortedLE_iff_getElem_le_getElem_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">j</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></div></div></div></div><div class="decl" id="List.sortedGE_iff_getElem_ge_getElem_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L490-L492">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_getElem_ge_getElem_of_le"><span class="name">List</span>.<span class="name">sortedGE_iff_getElem_ge_getElem_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></div></div></div></div><div class="decl" id="List.sortedLT_iff_getElem_lt_getElem_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L493-L495">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_getElem_lt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedLT_iff_getElem_lt_getElem_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></div></div></div></div><div class="decl" id="List.sortedGT_iff_getElem_gt_getElem_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L496-L498">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_getElem_gt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedGT_iff_getElem_gt_getElem_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></div></div></div></div><div class="decl" id="List.sortedLE_of_getElem_le_getElem_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L500-L501">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_of_getElem_le_getElem_of_le"><span class="name">List</span>.<span class="name">sortedLE_of_getElem_le_getElem_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">j</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span>)</span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_getElem_le_getElem_of_le">List.sortedLE_iff_getElem_le_getElem_of_le</a></code>.</p></div></div><div class="decl" id="List.SortedLE.getElem_le_getElem_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L500-L501">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.getElem_le_getElem_of_le"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">getElem_le_getElem_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">j</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_iff_getElem_le_getElem_of_le">List.sortedLE_iff_getElem_le_getElem_of_le</a></code>.</p></div></div><div class="decl" id="List.SortedGE.getElem_ge_getElem_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L502-L503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.getElem_ge_getElem_of_le"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">getElem_ge_getElem_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_getElem_ge_getElem_of_le">List.sortedGE_iff_getElem_ge_getElem_of_le</a></code>.</p></div></div><div class="decl" id="List.sortedGE_of_getElem_ge_getElem_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L502-L503">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_of_getElem_ge_getElem_of_le"><span class="name">List</span>.<span class="name">sortedGE_of_getElem_ge_getElem_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span>)</span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_iff_getElem_ge_getElem_of_le">List.sortedGE_iff_getElem_ge_getElem_of_le</a></code>.</p></div></div><div class="decl" id="List.sortedLT_of_getElem_lt_getElem_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L504-L505">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_of_getElem_lt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedLT_of_getElem_lt_getElem_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span>)</span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_getElem_lt_getElem_of_lt">List.sortedLT_iff_getElem_lt_getElem_of_lt</a></code>.</p></div></div><div class="decl" id="List.SortedLT.getElem_lt_getElem_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L504-L505">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.getElem_lt_getElem_of_lt"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">getElem_lt_getElem_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_getElem_lt_getElem_of_lt">List.sortedLT_iff_getElem_lt_getElem_of_lt</a></code>.</p></div></div><div class="decl" id="List.sortedGT_of_getElem_gt_getElem_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L506-L507">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_of_getElem_gt_getElem_of_lt"><span class="name">List</span>.<span class="name">sortedGT_of_getElem_gt_getElem_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span>)</span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_getElem_gt_getElem_of_lt">List.sortedGT_iff_getElem_gt_getElem_of_lt</a></code>.</p></div></div><div class="decl" id="List.SortedGT.getElem_gt_getElem_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L506-L507">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.getElem_gt_getElem_of_lt"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">getElem_gt_getElem_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn">∀ ⦃<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>⦄ ⦃<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄ ⦃<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>⦄, <span class="fn"><span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span> → <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a></span></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_getElem_gt_getElem_of_lt">List.sortedGT_iff_getElem_gt_getElem_of_lt</a></code>.</p></div></div><div class="decl" id="List.SortedLT.sortedLE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L513-L514">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.sortedLE"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">sortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.SortedGT.sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L515-L516">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.sortedGE"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="List.Sorted.le_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L518-L518">source</a></div><div class="attributes">@[deprecated List.SortedLT.sortedLE (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.le_of_lt"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">le_of_lt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.sortedLE">List.SortedLT.sortedLE</a></code>.</p></div></div><div class="decl" id="List.Sorted.ge_of_gt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L519-L519">source</a></div><div class="attributes">@[deprecated List.SortedGT.sortedGE (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.ge_of_gt"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">ge_of_gt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.sortedGE">List.SortedGT.sortedGE</a></code>.</p></div></div><div class="decl" id="List.SortedLT.nodup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L521-L521">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.nodup"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">nodup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span></div></div></div></div><div class="decl" id="List.SortedGT.nodup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L522-L522">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.nodup"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">nodup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span></div></div></div></div><div class="decl" id="List.sortedLE_replicate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L524-L525">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_replicate"><span class="name">List</span>.<span class="name">sortedLE_replicate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.replicate">replicate</a> <span class="fn">n</span> <span class="fn">a</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sorted_le_replicate"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L527-L527">source</a></div><div class="attributes">@[deprecated List.sortedLE_replicate (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_le_replicate"><span class="name">List</span>.<span class="name">sorted_le_replicate</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.replicate">replicate</a> <span class="fn">n</span> <span class="fn">a</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_replicate">List.sortedLE_replicate</a></code>.</p></div></div><div class="decl" id="List.sortedLT_finRange"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L529-L530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_finRange"><span class="name">List</span>.<span class="name">sortedLT_finRange</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/FinRange.html#List.finRange">finRange</a> <span class="fn">n</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="List.sortedLT_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L532-L532">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_range"><span class="name">List</span>.<span class="name">sortedLT_range</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.range">range</a> <span class="fn">n</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="List.sorted_lt_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L534-L534">source</a></div><div class="attributes">@[deprecated List.sortedLT_range (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_lt_range"><span class="name">List</span>.<span class="name">sorted_lt_range</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.range">range</a> <span class="fn">n</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_range">List.sortedLT_range</a></code>.</p></div></div><div class="decl" id="List.sorted_le_range"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L536-L538">source</a></div><div class="attributes">@[deprecated &quot;use sortedLT_range.sortedLE&quot; (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_le_range"><span class="name">List</span>.<span class="name">sorted_le_range</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.range">range</a> <span class="fn">n</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedLT_range'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L540-L541">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_range'"><span class="name">List</span>.<span class="name">sortedLT_range'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.range'">range'</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">s</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="List.sorted_lt_range'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L543-L543">source</a></div><div class="attributes">@[deprecated List.sortedLT_range' (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_lt_range'"><span class="name">List</span>.<span class="name">sorted_lt_range'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.range'">range'</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">s</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_range'">List.sortedLT_range'</a></code>.</p></div></div><div class="decl" id="List.sorted_le_range'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L545-L547">source</a></div><div class="attributes">@[deprecated &quot;use sortedLT_range'.sortedLE&quot; (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_le_range'"><span class="name">List</span>.<span class="name">sorted_le_range'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">s</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hs</span> : <span class="fn">s</span> <a href="../../.././Init/Core.html#Ne">≠</a> <span class="fn">0</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.range'">range'</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">s</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedLE_range'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L549-L550">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_range'"><span class="name">List</span>.<span class="name">sortedLE_range'</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">a </span><span class="fn">b </span><span class="fn">s</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/Basic.html#List.range'">range'</a> <span class="fn">a</span> <span class="fn">b</span> <span class="fn">s</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedLE_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L558-L561">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_ofFn_iff"><span class="name">List</span>.<span class="name">sortedLE_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">f</span></span></div></div><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is sorted with respect to <code>(· ≤ ·)</code> if and only if <code>f</code> is monotone.</p></div></div><div class="decl" id="List.sortedGE_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L563-L566">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_ofFn_iff"><span class="name">List</span>.<span class="name">sortedGE_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn">f</span></span></div></div><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is sorted with respect to <code>(· ≥ ·)</code> if and only if <code>f</code> is antitone.</p></div></div><div class="decl" id="List.sortedLT_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L568-L572">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_ofFn_iff"><span class="name">List</span>.<span class="name">sortedLT_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span></div></div><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is strictly sorted with respect to <code>(· ≤ ·)</code> if and only if <code>f</code> is
strictly monotone.</p></div></div><div class="decl" id="List.sortedGT_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L574-L578">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_ofFn_iff"><span class="name">List</span>.<span class="name">sortedGT_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span></div></div><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is strictly sorted with respect to <code>(· ≥ ·)</code> if and only if <code>f</code> is
strictly antitone.</p></div></div><div class="decl" id="List.sorted_le_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L580-L580">source</a></div><div class="attributes">@[deprecated List.sortedLE_ofFn_iff (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_le_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_le_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_ofFn_iff">List.sortedLE_ofFn_iff</a></code>.</p><hr></hr><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is sorted with respect to <code>(· ≤ ·)</code> if and only if <code>f</code> is monotone.</p></div></div><div class="decl" id="List.sorted_lt_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L581-L581">source</a></div><div class="attributes">@[deprecated List.sortedLT_ofFn_iff (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_lt_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_lt_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_ofFn_iff">List.sortedLT_ofFn_iff</a></code>.</p><hr></hr><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is strictly sorted with respect to <code>(· ≤ ·)</code> if and only if <code>f</code> is
strictly monotone.</p></div></div><div class="decl" id="List.sorted_ge_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L582-L582">source</a></div><div class="attributes">@[deprecated List.sortedGE_ofFn_iff (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_ge_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_ge_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_ofFn_iff">List.sortedGE_ofFn_iff</a></code>.</p><hr></hr><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is sorted with respect to <code>(· ≥ ·)</code> if and only if <code>f</code> is antitone.</p></div></div><div class="decl" id="List.sorted_gt_ofFn_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L583-L583">source</a></div><div class="attributes">@[deprecated List.sortedGT_ofFn_iff (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sorted_gt_ofFn_iff"><span class="name">List</span>.<span class="name">sorted_gt_ofFn_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_ofFn_iff">List.sortedGT_ofFn_iff</a></code>.</p><hr></hr><p>The list <code><a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> f</code> is strictly sorted with respect to <code>(· ≥ ·)</code> if and only if <code>f</code> is
strictly antitone.</p></div></div><div class="decl" id="Monotone.sortedLE_ofFn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L585-L586">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#Monotone.sortedLE_ofFn"><span class="name">Monotone</span>.<span class="name">sortedLE_ofFn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p>The list obtained from a monotone tuple is sorted.</p></div></div><div class="decl" id="List.SortedLE.monotone"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L585-L586">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.monotone"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">monotone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">f</span></span></span></div></div><p>The list obtained from a monotone tuple is sorted.</p></div></div><div class="decl" id="List.SortedGE.antitone"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L587-L588">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.antitone"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">antitone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn">f</span></span></span></div></div><p>The list obtained from an antitone tuple is sorted.</p></div></div><div class="decl" id="Antitone.sortedGE_ofFn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L587-L588">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#Antitone.sortedGE_ofFn"><span class="name">Antitone</span>.<span class="name">sortedGE_ofFn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p>The list obtained from an antitone tuple is sorted.</p></div></div><div class="decl" id="List.SortedLT.strictMono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L589-L590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.strictMono"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">strictMono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span></span></div></div><p>The list obtained from a strictly monotone tuple is sorted.</p></div></div><div class="decl" id="StrictMono.sortedLT_ofFn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L589-L590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictMono.sortedLT_ofFn"><span class="name">StrictMono</span>.<span class="name">sortedLT_ofFn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p>The list obtained from a strictly monotone tuple is sorted.</p></div></div><div class="decl" id="StrictAnti.sortedGT_ofFn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L591-L592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictAnti.sortedGT_ofFn"><span class="name">StrictAnti</span>.<span class="name">sortedGT_ofFn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p>The list obtained from a strictly antitone tuple is sorted.</p></div></div><div class="decl" id="List.SortedGT.strictAnti"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L591-L592">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.strictAnti"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">strictAnti</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span></span></div></div><p>The list obtained from a strictly antitone tuple is sorted.</p></div></div><div class="decl" id="Antitone.ofFn_sorted"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L594-L595">source</a></div><div class="attributes">@[deprecated Antitone.sortedGE_ofFn (since := &quot;2025-10-13&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#Antitone.ofFn_sorted"><span class="name">Antitone</span>.<span class="name">ofFn_sorted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Antitone">Antitone</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_ofFn_iff">List.sortedGE_ofFn_iff</a></code>.</p><hr></hr><p>The list obtained from an antitone tuple is sorted.</p></div></div><div class="decl" id="Monotone.ofFn_sorted"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L596-L597">source</a></div><div class="attributes">@[deprecated Monotone.sortedLE_ofFn (since := &quot;2025-10-13&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#Monotone.ofFn_sorted"><span class="name">Monotone</span>.<span class="name">ofFn_sorted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">n</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#Monotone">Monotone</a> <span class="fn">f</span></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Data/List/OfFn.html#List.ofFn">List.ofFn</a> <span class="fn">f</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_ofFn_iff">List.sortedLE_ofFn_iff</a></code>.</p><hr></hr><p>The list obtained from a monotone tuple is sorted.</p></div></div><div class="decl" id="List.sortedLE_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L603-L603">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_reverse"><span class="name">List</span>.<span class="name">sortedLE_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="List.sortedGE_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L604-L604">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_reverse"><span class="name">List</span>.<span class="name">sortedGE_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedLT_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L605-L605">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_reverse"><span class="name">List</span>.<span class="name">sortedLT_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="List.sortedGT_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L606-L606">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_reverse"><span class="name">List</span>.<span class="name">sortedGT_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="List.SortedGE.reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L608-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.reverse"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_reverse">List.sortedLE_reverse</a></code>.</p></div></div><div class="decl" id="List.SortedLE.of_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L608-L608">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.of_reverse"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">of_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_reverse">List.sortedLE_reverse</a></code>.</p></div></div><div class="decl" id="List.SortedGE.of_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L609-L609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.of_reverse"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">of_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_reverse">List.sortedGE_reverse</a></code>.</p></div></div><div class="decl" id="List.SortedLE.reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L609-L609">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.reverse"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_reverse">List.sortedGE_reverse</a></code>.</p></div></div><div class="decl" id="List.SortedLT.of_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L610-L610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.of_reverse"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">of_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_reverse">List.sortedLT_reverse</a></code>.</p></div></div><div class="decl" id="List.SortedGT.reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L610-L610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.reverse"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_reverse">List.sortedLT_reverse</a></code>.</p></div></div><div class="decl" id="List.SortedLT.reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L611-L611">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.reverse"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_reverse">List.sortedGT_reverse</a></code>.</p></div></div><div class="decl" id="List.SortedGT.of_reverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L611-L611">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.of_reverse"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">of_reverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_reverse">List.sortedGT_reverse</a></code>.</p></div></div><div class="decl" id="List.sortedLE_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L621-L622">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_map_ofDual"><span class="name">List</span>.<span class="name">sortedLE_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="List.sortedGE_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L623-L624">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_map_ofDual"><span class="name">List</span>.<span class="name">sortedGE_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedLT_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L625-L626">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_map_ofDual"><span class="name">List</span>.<span class="name">sortedLT_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="List.sortedGT_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L627-L628">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_map_ofDual"><span class="name">List</span>.<span class="name">sortedGT_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="List.SortedGE.of_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L630-L630">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">of_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_map_ofDual">List.sortedLE_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.SortedLE.map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L630-L630">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.map_ofDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_map_ofDual">List.sortedLE_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.SortedGE.map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L631-L631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.map_ofDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_map_ofDual">List.sortedGE_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.SortedLE.of_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L631-L631">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">of_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_map_ofDual">List.sortedGE_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.SortedGT.of_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L632-L632">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">of_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_map_ofDual">List.sortedLT_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.SortedLT.map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L632-L632">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.map_ofDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_map_ofDual">List.sortedLT_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.SortedLT.of_map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L633-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.of_map_ofDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">of_map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_map_ofDual">List.sortedGT_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.SortedGT.map_ofDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L633-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.map_ofDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">map_ofDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.ofDual">OrderDual.ofDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_map_ofDual">List.sortedGT_map_ofDual</a></code>.</p></div></div><div class="decl" id="List.sortedLE_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L641-L642">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_map_toDual"><span class="name">List</span>.<span class="name">sortedLE_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="List.sortedGE_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L643-L644">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_map_toDual"><span class="name">List</span>.<span class="name">sortedGE_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedLT_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L645-L646">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_map_toDual"><span class="name">List</span>.<span class="name">sortedLT_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="List.sortedGT_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L647-L648">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_map_toDual"><span class="name">List</span>.<span class="name">sortedGT_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="List.SortedLE.map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L650-L650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.map_toDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_map_toDual">List.sortedLE_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedGE.of_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L650-L650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.of_map_toDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">of_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_map_toDual">List.sortedLE_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedLE.of_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L651-L651">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.of_map_toDual"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">of_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_map_toDual">List.sortedGE_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedGE.map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L651-L651">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.map_toDual"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_map_toDual">List.sortedGE_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedLT.map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L652-L652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.map_toDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_map_toDual">List.sortedLT_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedGT.of_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L652-L652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.of_map_toDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">of_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_map_toDual">List.sortedLT_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedGT.map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L653-L653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.map_toDual"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> → <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></span></div></div><p><strong>Alias</strong> of the forward direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_map_toDual">List.sortedGT_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedLT.of_map_toDual"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L653-L653">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.of_map_toDual"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">of_map_toDual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span><a href="../../.././Mathlib/Order/Basic.html#OrderDual">ᵒᵈ</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> → <span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">map</a> <span class="fn">(⇑<a href="../../.././Mathlib/Order/Synonym.html#OrderDual.toDual">OrderDual.toDual</a>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></span></div></div><p><strong>Alias</strong> of the reverse direction of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_map_toDual">List.sortedGT_map_toDual</a></code>.</p></div></div><div class="decl" id="List.SortedLE.sortedLT_of_nodup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L665-L666">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.sortedLT_of_nodup"><span class="name">List</span>.<span class="name">SortedLE</span>.<span class="name">sortedLT_of_nodup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="List.SortedGE.sortedGT_of_nodup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L668-L669">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.sortedGT_of_nodup"><span class="name">List</span>.<span class="name">SortedGE</span>.<span class="name">sortedGT_of_nodup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="List.Sorted.lt_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L671-L671">source</a></div><div class="attributes">@[deprecated List.SortedLE.sortedLT_of_nodup (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.lt_of_le"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">lt_of_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE.sortedLT_of_nodup">List.SortedLE.sortedLT_of_nodup</a></code>.</p></div></div><div class="decl" id="List.Sorted.gt_of_ge"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L672-L672">source</a></div><div class="attributes">@[deprecated List.SortedGE.sortedGT_of_nodup (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Sorted.gt_of_ge"><span class="name">List</span>.<span class="name">Sorted</span>.<span class="name">gt_of_ge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE.sortedGT_of_nodup">List.SortedGE.sortedGT_of_nodup</a></code>.</p></div></div><div class="decl" id="List.sortedLT_iff_nodup_and_sortedLE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L674-L675">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLT_iff_nodup_and_sortedLE"><span class="name">List</span>.<span class="name">sortedLT_iff_nodup_and_sortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedGT_iff_nodup_and_sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGT_iff_nodup_and_sortedGE"><span class="name">List</span>.<span class="name">sortedGT_iff_nodup_and_sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Basic.html#List.Nodup">Nodup</a></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="List.Perm.eq_of_sortedLE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L680-L682">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Perm.eq_of_sortedLE"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_of_sortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.Perm.eq_of_sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L684-L686">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Perm.eq_of_sortedGE"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_of_sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.Subset.antisymm_of_sortedLT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L688-L690">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Subset.antisymm_of_sortedLT"><span class="name">List</span>.<span class="name">Subset</span>.<span class="name">antisymm_of_sortedLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂</span> : <span class="fn">l₁</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂'</span> : <span class="fn">l₂</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">l₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.Subset.antisymm_of_sortedGT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L692-L694">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Subset.antisymm_of_sortedGT"><span class="name">List</span>.<span class="name">Subset</span>.<span class="name">antisymm_of_sortedGT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂</span> : <span class="fn">l₁</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁₂'</span> : <span class="fn">l₂</span> <a href="../../.././Init/Core.html#HasSubset.Subset">⊆</a> <span class="fn">l₁</span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.SortedLT.eq_of_mem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L696-L698">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.eq_of_mem_iff"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">eq_of_mem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.SortedGT.eq_of_mem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L700-L702">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.eq_of_mem_iff"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">eq_of_mem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></div></div></div></div><div class="decl" id="List.Perm.eq_reverse_of_sortedLE_of_sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L704-L706">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.Perm.eq_reverse_of_sortedLE_of_sortedGE"><span class="name">List</span>.<span class="name">Perm</span>.<span class="name">eq_reverse_of_sortedLE_of_sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Perm">Perm</a></span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span></div></div></div></div><div class="decl" id="List.SortedLT.eq_reverse_of_mem_iff_of_sortedGT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L708-L710">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.eq_reverse_of_mem_iff_of_sortedGT"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">eq_reverse_of_mem_iff_of_sortedGT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span></div></div></div></div><div class="decl" id="List.SortedGT.eq_reverse_of_mem_iff_of_sortedLT"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L712-L715">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.eq_reverse_of_mem_iff_of_sortedLT"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">eq_reverse_of_mem_iff_of_sortedLT</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">a</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">l₁</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Init/Data/List/Basic.html#List.reverse">reverse</a></span></div></div></div></div><div class="decl" id="List.sublist_of_subperm_of_sortedLE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L717-L718">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sublist_of_subperm_of_sortedLE"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_sortedLE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Batteries/Data/List/Basic.html#List.Subperm">Subperm</a></span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l₂</span></span></div></div></div></div><div class="decl" id="List.sublist_of_subperm_of_sortedGE"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L720-L721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sublist_of_subperm_of_sortedGE"><span class="name">List</span>.<span class="name">sublist_of_subperm_of_sortedGE</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l₁ </span><span class="fn">l₂</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hp</span> : <span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Batteries/Data/List/Basic.html#List.Subperm">Subperm</a></span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₁</span> : <span class="fn"><span class="fn">l₁</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(<span class="fn">hl₂</span> : <span class="fn"><span class="fn">l₂</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l₁</span>.<a href="../../.././Init/Data/List/Basic.html#List.Sublist">Sublist</a></span> <span class="fn">l₂</span></span></div></div></div></div><div class="decl" id="List.sortedLE_mergeSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L729-L730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_mergeSort"><span class="name">List</span>.<span class="name">sortedLE_mergeSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.mergeSort">mergeSort</a></span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span></span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedGE_mergeSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L732-L733">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_mergeSort"><span class="name">List</span>.<span class="name">sortedGE_mergeSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Data/List/Sort/Basic.html#List.mergeSort">mergeSort</a></span> <span class="fn">fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span></span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="List.sortedLE_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L735-L736">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedLE_insertionSort"><span class="name">List</span>.<span class="name">sortedLE_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x2</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="List.sortedGE_insertionSort"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L738-L739">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.sortedGE_insertionSort"><span class="name">List</span>.<span class="name">sortedGE_insertionSort</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Mathlib/Data/List/Sort.html#List.insertionSort">insertionSort</a> <span class="fn">(fun (<span class="fn">x1</span> <span class="fn">x2</span> : <span class="fn">α</span>) =&gt; <span class="fn">x1</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x2</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="List.SortedLT.getElem_le_getElem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L741-L743">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.getElem_le_getElem_iff"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">getElem_le_getElem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">j</span></div></div></div></div><div class="decl" id="List.SortedGT.getElem_le_getElem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L745-L747">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.getElem_le_getElem_iff"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">getElem_le_getElem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span></div></div></div></div><div class="decl" id="List.SortedLT.getElem_lt_getElem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L749-L751">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT.getElem_lt_getElem_iff"><span class="name">List</span>.<span class="name">SortedLT</span>.<span class="name">getElem_lt_getElem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">j</span></div></div></div></div><div class="decl" id="List.SortedGT.getElem_lt_getElem_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L753-L755">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT.getElem_lt_getElem_iff"><span class="name">List</span>.<span class="name">SortedGT</span>.<span class="name">getElem_lt_getElem_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hl</span> : <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">i </span><span class="fn">j</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hi</span> : <span class="fn">i</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">hj</span> : <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Init/Prelude.html#List.length">length</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">i</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">l</span><a href="../../.././Init/GetElem.html#GetElem.getElem">[</a><span class="fn">j</span><a href="../../.././Init/GetElem.html#GetElem.getElem">]</a> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">j</span> <a href="../../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">i</span></div></div></div></div><div class="decl" id="RelEmbedding.pairwise_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L769-L771">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#RelEmbedding.pairwise_listMap"><span class="name">RelEmbedding</span>.<span class="name">pairwise_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ra</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rb</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ra</span> <a href="../../.././Mathlib/Order/RelIso/Basic.html#RelEmbedding">↪r</a> <span class="fn">rb</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">rb</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">ra</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="RelEmbedding.sorted_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L773-L773">source</a></div><div class="attributes">@[deprecated RelEmbedding.pairwise_listMap (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#RelEmbedding.sorted_listMap"><span class="name">RelEmbedding</span>.<span class="name">sorted_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ra</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rb</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ra</span> <a href="../../.././Mathlib/Order/RelIso/Basic.html#RelEmbedding">↪r</a> <span class="fn">rb</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">rb</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">ra</span> <span class="fn">l</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#RelEmbedding.pairwise_listMap">RelEmbedding.pairwise_listMap</a></code>.</p></div></div><div class="decl" id="RelEmbedding.pairwise_swap_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L775-L778">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#RelEmbedding.pairwise_swap_listMap"><span class="name">RelEmbedding</span>.<span class="name">pairwise_swap_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ra</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rb</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ra</span> <a href="../../.././Mathlib/Order/RelIso/Basic.html#RelEmbedding">↪r</a> <span class="fn">rb</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">rb</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">ra</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="RelEmbedding.sorted_swap_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L780-L780">source</a></div><div class="attributes">@[deprecated RelEmbedding.pairwise_swap_listMap (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#RelEmbedding.sorted_swap_listMap"><span class="name">RelEmbedding</span>.<span class="name">sorted_swap_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ra</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rb</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ra</span> <a href="../../.././Mathlib/Order/RelIso/Basic.html#RelEmbedding">↪r</a> <span class="fn">rb</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">rb</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">ra</span>)</span> <span class="fn">l</span></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#RelEmbedding.pairwise_swap_listMap">RelEmbedding.pairwise_swap_listMap</a></code>.</p></div></div><div class="decl" id="RelIso.pairwise_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L788-L790">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#RelIso.pairwise_listMap"><span class="name">RelIso</span>.<span class="name">pairwise_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ra</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rb</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ra</span> <a href="../../.././Mathlib/Order/RelIso/Basic.html#RelIso">≃r</a> <span class="fn">rb</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">rb</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">ra</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="RelIso.pairwise_swap_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L792-L795">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#RelIso.pairwise_swap_listMap"><span class="name">RelIso</span>.<span class="name">pairwise_swap_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">ra</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">rb</span> : <span class="fn"><span class="fn">β</span> → <span class="fn">β</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">ra</span> <a href="../../.././Mathlib/Order/RelIso/Basic.html#RelIso">≃r</a> <span class="fn">rb</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">rb</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.Pairwise">List.Pairwise</a> <span class="fn">(<a href="../../.././Mathlib/Logic/Function/Defs.html#Function.swap">Function.swap</a> <span class="fn">ra</span>)</span> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="OrderEmbedding.sortedLE_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L805-L808">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedLE_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedLE_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="OrderEmbedding.sortedLT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L810-L814">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedLT_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedLT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="OrderEmbedding.sortedGE_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L816-L819">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedGE_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedGE_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="OrderEmbedding.sortedGT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L821-L824">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedGT_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sortedGT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="OrderEmbedding.sorted_le_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L826-L826">source</a></div><div class="attributes">@[deprecated OrderEmbedding.sortedLE_listMap (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sorted_le_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_le_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedLE_listMap">OrderEmbedding.sortedLE_listMap</a></code>.</p></div></div><div class="decl" id="OrderEmbedding.sorted_lt_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L827-L827">source</a></div><div class="attributes">@[deprecated OrderEmbedding.sortedLT_listMap (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sorted_lt_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_lt_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedLT_listMap">OrderEmbedding.sortedLT_listMap</a></code>.</p></div></div><div class="decl" id="OrderEmbedding.sorted_ge_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L828-L828">source</a></div><div class="attributes">@[deprecated OrderEmbedding.sortedGE_listMap (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sorted_ge_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_ge_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedGE_listMap">OrderEmbedding.sortedGE_listMap</a></code>.</p></div></div><div class="decl" id="OrderEmbedding.sorted_gt_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L829-L829">source</a></div><div class="attributes">@[deprecated OrderEmbedding.sortedGT_listMap (since := &quot;2025-11-27&quot;)]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sorted_gt_listMap"><span class="name">OrderEmbedding</span>.<span class="name">sorted_gt_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderEmbedding">↪o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div><p><strong>Alias</strong> of <code><a href="../../.././Mathlib/Data/List/Sort.html#OrderEmbedding.sortedGT_listMap">OrderEmbedding.sortedGT_listMap</a></code>.</p></div></div><div class="decl" id="OrderIso.sortedLT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L837-L840">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderIso.sortedLT_listMap"><span class="name">OrderIso</span>.<span class="name">sortedLT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderIso">≃o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="OrderIso.sortedGT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L842-L845">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#OrderIso.sortedGT_listMap"><span class="name">OrderIso</span>.<span class="name">sortedGT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">e</span> : <span class="fn">α</span> <a href="../../.././Mathlib/Order/Hom/Basic.html#OrderIso">≃o</a> <span class="fn">β</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">(⇑<span class="fn">e</span>)</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="StrictMono.sortedLE_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L853-L855">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictMono.sortedLE_listMap"><span class="name">StrictMono</span>.<span class="name">sortedLE_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="StrictMono.sortedGE_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L857-L859">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictMono.sortedGE_listMap"><span class="name">StrictMono</span>.<span class="name">sortedGE_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="StrictMono.sortedLT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L861-L863">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictMono.sortedLT_listMap"><span class="name">StrictMono</span>.<span class="name">sortedLT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div><div class="decl" id="StrictMono.sortedGT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L865-L867">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictMono.sortedGT_listMap"><span class="name">StrictMono</span>.<span class="name">sortedGT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictMono">StrictMono</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="StrictAnti.sortedLE_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L877-L880">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictAnti.sortedLE_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedLE_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span></div></div></div></div><div class="decl" id="StrictAnti.sortedGE_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L882-L885">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictAnti.sortedGE_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedGE_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGE">SortedGE</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLE">SortedLE</a></span></div></div></div></div><div class="decl" id="StrictAnti.sortedLT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L887-L890">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictAnti.sortedLT_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedLT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span></div></div></div></div><div class="decl" id="StrictAnti.sortedGT_listMap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/a3a10db0e9d66acbebf76c5e6a135066525ac900/Mathlib/Data/List/Sort.lean#L892-L895">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/List/Sort.html#StrictAnti.sortedGT_listMap"><span class="name">StrictAnti</span>.<span class="name">sortedGT_listMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">β</span> : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/LinearOrder.html#LinearOrder">LinearOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Defs/PartialOrder.html#Preorder">Preorder</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">f</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{<span class="fn">l</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(<span class="fn">hf</span> : <span class="fn"><a href="../../.././Mathlib/Order/Monotone/Defs.html#StrictAnti">StrictAnti</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<a href="../../.././Init/Prelude.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">l</span>)</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedGT">SortedGT</a></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l</span>.<a href="../../.././Mathlib/Data/List/Sort.html#List.SortedLT">SortedLT</a></span></div></div></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>